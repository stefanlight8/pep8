# PEP 8 и как писать код грамотно.
Привет, в этой статье я хочу рассмотреть то, как писать красивый код, и правило PEP 8 – "Style Guide for Python Code".

Пожалуй, начнём с самого банального

# Импорты
Самое важное в больших проектах и самое неважное для начинающих.

Давайте рассмотрим примеры:
- Каждый импорт должен находится на отдельной строчке для структурности.
  ```py
  # Неправильно
  import psutil, sys, importlib
  # Правильно
  import psutil
  import sys
  import importlib
  ```
  И надо учесть, что `import` и `from ... import ...` разные вещи и...
  ```py
  # Правильно
  from logging import getLogger
  ```
- Импорты должны быть структурны, поэтому...
  ```py
  # Сначала идут встроенные библиотеки
  import importlib
  import sys
  from logging import getLogger
  # Потом внешние
  import psutil
  # А потом уже импорты модулей вашего проекта
  from mypkg import something
  ```
  А также, надо отметить, что желательно, чтобы они были в алфавитном порядке и, что сначала идут `import` и только потом `from ... import ...`.
  C порядком импортов вам могут помочь легко: [`ruff`](https://docs.astral.sh/ruff/) и [`isort`](https://pycqa.github.io/isort/).
- Я и PEP 8 рекомендуем абсолютные импорты.
  Абсолютные импорты это, когда вы указываете полный путь до какого-то модуля и что из него импортировать или его самого.
  ```py
  # Относительные импорты:
  from asyncio import Task, AbstractEventLoop
  # Абсолютные импорты:
  from asyncio.tasks import Task
  from asyncio.events import AbstractEventLoop
  ```
  Они более читабельные и понятные, но из-за этого они становится большими, но лично для меня это не является проблемой.
  Теперь рассмотрим случай с внутренними импортами вашего проекта.
  ```py
  # Относительные импорты:
  from . import something
  from .cool import sunglasses
  # Абсолютные импорты:
  from mypkg import something
  from mypkg.cool import sunglasses
  ```
  Выглядит не очень, так что в этом случае лучше всего делать абсолютные импорты.
- PEP 8 рекомендует избегать `from ... import *` – такая конструкция импортирует всё из модуля.
  Такое можно использовать, если вы заранее указываете в вашем модуле `__all__` – переменная, которая определяет, что есть в вашем модуле.
  Без `__all__`, `*` является очень сложной конструкцией, которая импортирует слишком много всего и сама определяет, это медленно.
- Ещё, нормально называть ваш модуль `mypkg.anotherclass`, если он имеет класс, это тогда будет что-то типо: `mypkg.anotherclass.MyClass`.
  ```py
  from mypkg.anotherclass import MyClass
  # Или
  import mypkg.anotherclass.MyClass
  ```

# Модули
Раз уж на то пошло, то обсудим строение модуля.
```py
# Представим, что это __init__ нашего мега-крутого модуля.
"""Module with cool class

That doing nothing
"""
# Сначала идёт строка документации (docstring)
# Потом идут импорты из __future__ (подробнее в конце)
from __future__ import annotations
# Далее идут “dunders” (дандеры) модуля. И к ним относятся __all__.
__all__ = ("a", "b", "c")
__version__ = "302.2"  # __version__
__author__ = "stefanlight"
# Далее идут уже импорты вашего модуля
import sys

import psutil

from mypkg.anotherclass import CoolClass
```
В Python `__future__` – это в прямом смысле будущее. Оно позволяет адаптироваться к новвоведениям и смотреть в будущее.
Например, представленный в коде `from __future__ import annotations` позволяет отвязать аннотации от реальных объектов, превращая их в строки.

